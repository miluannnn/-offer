1.java 二维数组：列数和行数
	int rows = array.length;
	int cols = array[0].length；
   C++也一样。
2.字符串的替换输出：str.toString().replace(" ", "");
3.从头至尾返回一个链表。重点看一下递归的方法。
   Java里数组的声明：ArrayList<Integer> list = new ArrayList();
4.二叉树：摘抄 !!!!
<<<<<<< HEAD
根据中序遍历和前序遍历可以确定二叉树，具体过程为：
根据前序序列第一个结点确定根结点 
根据根结点在中序序列中的位置分割出左右两个子序列 
对左子树和右子树分别递归使用同样的方法继续分解 
例如：
前序序列{1,2,4,7,3,5,6,8} = pre
中序序列{4,7,2,1,5,3,8,6} = in
根据当前前序序列的第一个结点确定根结点，为 1 
找到 1 在中序遍历序列中的位置，为 in[3] 
切割左右子树，则 in[3] 前面的为左子树， in[3] 后面的为右子树 
则切割后的左子树前序序列为：{2,4,7}，切割后的左子树中序序列为：{4,7,2}；切割后的右子树前序序列为：{3,5,6,8}，切割后的右子树中序序列为：{5,3,8,6} 
对子树分别使用同样的方法分
5.两个栈实现一个队列  很巧妙
6.二分法
7.0 1 1 2 3 
8. 1<<n
    2的n次方 1 向右移n位
    3 << 2，则是将数字3左移2位
11 与运算： &
12 n次方 
如果exponent是偶数，Power(base, exponent) = Power(base, exponent / 2) * Power(base, exponent / 2) 
如果exponent是奇数，Power(base, exponent) = base * Power(base, exponent / 2) * Power(base, exponent / 2) 
=======
    根据中序遍历和前序遍历可以确定二叉树，具体过程为：
    根据前序序列第一个结点确定根结点 
    根据根结点在中序序列中的位置分割出左右两个子序列 
    对左子树和右子树分别递归使用同样的方法继续分解 
    例如：
    前序序列{1,2,4,7,3,5,6,8} = pre
    中序序列{4,7,2,1,5,3,8,6} = in
    根据当前前序序列的第一个结点确定根结点，为 1 
    找到 1 在中序遍历序列中的位置，为 in[3] 
    切割左右子树，则 in[3] 前面的为左子树， in[3] 后面的为右子树 
    则切割后的左子树前序序列为：{2,4,7}，切割后的左子树中序序列为：{4,7,2}；切割后的右子树前序序列为：{3,5,6,8}，切割后的右子树中序序列为：{5,3,8,6} 
    对子树分别使用同样的方法分
>>>>>>> jyj
