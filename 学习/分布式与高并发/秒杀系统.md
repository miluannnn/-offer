# 秒杀系统

## 一、超卖问题

### 1. 如何解决超卖问题

```
--在sql加上判断防止数据边为负数 
--数据库加唯一索引防止用户重复购买
--redis预减库存减少数据库访问　内存标记减少redis访问　请求先入队列缓冲，异步下单，增强用户体验
```

####  全局异常处理

```
1.定义全局的异常拦截器
2.定义了全局异常类型
3.只返回和业务有关的
4.详情请看GlobleException
```

#### 页面级缓存

```
 1.详细请看basecontroller 缓存渲染页面
```

#### 对象级缓存redis

```
 redis永久缓存对象减少压力
 redis预减库存减少数据库访
 内存标记方法减少redis访问
```

#### 订单处理队列rabbitmq

```
请求先入队缓冲，异步下单，增强用户体验
 请求出队，生成订单，减少库存
 客户端定时轮询检查是否秒杀成功 
```

#### 解决分布式session

```
--生成随机的uuid作为cookie返回并redis内存写入 
--拦截器每次拦截方法，来重新获根据cookie获取对象
--下一个页面拿到key重新获取对象
--HandlerMethodArgumentResolver 方法 supportsParameter 如果为true 执行 resolveArgument 方法获取miaoshauser对象
--如果有缓存的话 这个功能实现起来就和简单，在一个用户访问接口的时候我们把访问次数写到缓存中，在加上一个有效期。
   通过拦截器. 做一个注解 @AccessLimit 然后封装这个注解，可以有效的设置每次访问多少次，有效时间是否需要登录！
```

#### 秒杀安全 --安全性设计

```
 秒杀接口隐藏
 数字公式验证码
 接口防刷限流(通用 注解，拦截器方式)
```

#### 通用缓存key的封装采用什么设计模式

```
模板模式的优点
-具体细节步骤实现定义在子类中，子类定义详细处理算法是不会改变算法整体结构
-代码复用的基本技术，在数据库设计中尤为重要
-存在一种反向的控制结构，通过一个父类调用其子类的操作，通过子类对父类进行扩展增加新的行为，符合“开闭原则”
-缺点：　每个不同的实现都需要定义一个子类，会导致类的个数增加，系统更加庞大
```

#### redis库存如何于数据库库存保持一致

```
redis的数量不是库存,他的作用仅仅只是为了阻挡多余的请求透穿到DB，起到一个保护的作用
因为秒杀的商品有限，比如10个，让1万个请求区访问DB是没有意义的，因为最多也就只能10个
请求下单成功，所有这个是一个伪命题，我们是不需要保持一致的
```

#### redis预减成功，DB扣减库存失败怎么办

```
-其实我们可以不用太在意，对用户而言，秒杀不中是正常现象，秒杀中才是意外，单个用户秒杀中
-1.本来就是小概率事件，出现这种情况对于用户而言没有任何影响
-2.对于商户而言，本来就是为了活动拉流量人气的，卖不完还可以省一部分费用，但是活动还参与了，也就没有了任何影响
-3.对网站而言，最重要的是体验，只要网站不崩溃，对用户而言没有任何影响
```

#### 为什么redis数量会减少为负数

```java
//预减库存
    long stock = redisService.decr(GoodsKey.getMiaoshaGoodsStock,""+goodsId) ;
	if(stock <0){
    localOverMap.put(goodsId, true);
	return Result.error(CodeMsg.MIAO_SHA_OVER);
	}
	假如redis的数量为1,这个时候同时过来100个请求，大家一起执行decr数量就会减少成-99这个是正常的
	进行优化后改变了sql写法和内存写法则不会出现上述问题
```

#### 为什么单独维护一个秒杀系统标志

```
-1.前提所有的秒杀相关的接口都要加上活动是否结束的标志，如果结束就直接返回，包括轮寻的接口防止一直轮寻
 -2.管理后台也可以手动的更改这个标志，防止出现活动开始以后就没办法结束这种意外的事件
```

#### redis 分布式锁实现方法

```
我用了四种方法 ， 分别指出了不同版本的缺陷以及演进的过程 orderclosetask
V1---->>版本没有操作，在分布式系统中会造成同一时间，资源浪费而且很容易出现并发问题
V2--->>版本加了分布式redis锁，在访问核心方法前，加入redis锁可以阻塞其他线程访问,可以
很好的处理并发问题,但是缺陷就是如果机器突然宕机，或者线路波动等，就会造成死锁，一直
不释放等问题
V3版本-->>很好的解决了这个问题v2的问题，就是加入时间对比如果当前时间已经大与释放锁的时间
说明已经可以释放这个锁重新在获取锁，setget方法可以把之前的锁去掉在重新获取,旧值在于之前的
值比较，如果无变化说明这个期间没有人获取或者操作这个redis锁，则可以重新获取
V4---->>采用成熟的框架redisson,封装好的方法则可以直接处理，但是waittime记住要这只为0
```