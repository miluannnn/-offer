## 线程安全与数据同步

[TOC]



### synchronized关键字

> synchronized可以用于对**代码块**或**方法**进行修饰，而不能用于对类和变量进行修饰

1. 同步方法：

   ```java
   （public)  synchronized (static) type method()
   ```

2. 同步代码块：

   ```java
   private final Object MUTEX = new Object();
   private void sync(){
   	sychronized(MUTEX){
   		...
   	}
   }
   ```

### 深入sychronized关键字

- 某线程获取了与MUTEX关联的monitor锁

- 使用sychronized需要注意的问题：

  1. monitor关联的对象不能为空

     ```java
     private final Object MUTEX = null;
     private void sync(){
     	sychronized(MUTEX){
     		...
     	}
     }
     ```

     

  2. 所有代码会串行在sychronized保护的区域。作用域太大丧失并行的优势。

  3. 不同的monitor不能锁一个方法。

## 深入理解volatile

### java内存模型

![img](https://images0.cnblogs.com/i/475287/201403/091134177063947.jpg)

- 共享变量存储于主内存之中，每个线程都可以访问
- 每个线程私有的工作内存或者称为本地内存
- 工作内存只存储该线程对共享变量的副本
- 线程不能直接操作主内存，操作工作内存之后才能写入主内存
- 工作内存和Java内存模型一样是个抽象概念，其实不存在



### 并发编程的三个重要特性

#### 1.原子性

	- 多个原子性的操作在一起不再是原子性。
	- **volatile不保证原子性。**

#### 2.可见性

			- 使用volatile：当一个变量被volatile修饰，对于共享变量的读操作会在主内存中进行，写操作先修改工作内存，然后立即刷新到主内存。
			- 使用synchronized:一个线程获得锁，执行同步方法
			- JUC提供的显示锁lock

#### 3.有序性

- volatile
- sychronized
- Lock显示锁

